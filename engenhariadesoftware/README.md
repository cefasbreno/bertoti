# Atividade 1

## Artigo 1
As engenharias mais tradicionais, como mecânica e civil, são caracterizadas por serem tangíveis, possuírem regras rigorosas e métodos comprovados empiricamente. A engenharia de software, por sua vez, não possui tais características, o que a diferencia de todas as outras. Os engenheiros de software se diferenciam de outros por trabalharem com algo que não existe no mundo físico de forma natural. Um engenheiro elétrico, mesmo não a vendo a olhos nus, consegue saber se há ou não corrente elétrica em um sistema, pois a eletricidade é uma propriedade e pode ser medida. Por isso, a engenharia de software é tratada de maneira diferente das outras, pois não trabalha com algo totalmente tátil, mas sim com algoritmos e lógicas criados de humanos para humanos.

## Artigo 2
Um código não é só escrito por programadores uma vez e dura para sempre. Na verdade, quando se escreve um programa, seja qual for sua finalidade, é preciso ter estratégias de abordagem externas capazes de manter o código funcional através do tempo. O artigo utiliza o termo "código sustentável" para designar um código que está apto para receber mudanças futuras em sua estrutura. É um processo trabalhoso, e as organizações têm se dedicado à descobrir abordagens que priorizem essa característica de sustentabilidade em software, pois esse trabalho resulta em menos desgastes com manutenções excessivas e perca de utilidade.

## Requisitos não-funcionais
### 1. Escalabilidade:
Determina quão bem o sistema performará com o aumento escalar de usuários e requisições;
### 2. Performance:
Determina quão rápido o sistema atenderá às requisições dos usuários, baseando-se no recursos disponíveis;
### 3. Robustez:
Determina a capacidade do sistema de manter-se operante, mesmo com erros de hardware, conexão ou energia;
### 4. Extensibilidade:
Determina quão fácil é de se aplicar extensões e melhorias ao sistema. Isso envolve muitas características, como arquitetura e engenharia de software;
### 5. Testabilidade:
Determina a qualidade do sistema ao realizar testes em seu desenvolvimento. Muito importante na qualidade de software, verifica a facilidade de aplicação de métodos e seus resultados.

## Trade-offs
### 1. Monolito vs. microsserviços:
Ao optar pelo monolito, tem-se facilidade no desenvolvimento inicial, impactando diretamente no tempo de lançamento. Entretanto, espera-se problemas com escalabilidade no futuro;
### 2. Performance vs. memória:
Ao optar pela performance, utiliza-se também de mais memória. Isso é muito benéfico para popularidade, mas pode perder usuários que possuem máquinas menos potentes;
### 3. Tempo de implementação vs. qualidade do código:
Manter-se à frente da concorrência a todo custo exige atualizações constantes e profundas. Para isso, a qualidade do código é preterida para dar lugar a novas mecânicas, que podem ser pouco testadas.
